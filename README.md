**Степина Алёна ИТ-2 Лабораторная №3**

---

### **Задание 1**
#### **Задача 4**
**Текст задачи**  
Дроби. 
Измените сущность Дробь из задачи 1.5.5. Реализуйте следующие требования:
• Дробь не может быть изменена после создания
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель 
не может быть отрицательным. 
Продемонстрируйте работоспособность решения на примерах.

**Алгоритм решения**  
##### 1. **Определение класса `Fraction` **
- Дробь представляется двумя целыми числами:
  - `numer` — числитель,
  - `denom` — знаменатель (не может быть нулём).
- При создании дроби:
  - Проверяется, что знаменатель ≠ 0.
  - Если знаменатель отрицательный, знак переносится на числитель.
  - Дробь автоматически упрощается с помощью НОД (наибольшего общего делителя).
- Реализованы методы для арифметических операций:
  - `plus()` — сложение,
  - `minus()` — вычитание,
  - `times()` — умножение,
  - `divide()` — деление (с проверкой деления на ноль).
- Вспомогательный метод `gcd()` вычисляет НОД по алгоритму Евклида.
- Переопределён `toString()`, чтобы дроби отображались в виде `a/b`, а целые числа — как `a`.

##### 2. **Основной цикл калькулятора (`UnitOneOne.run`)**
- Программа работает в интерактивном режиме через консоль.
- Используется объект `Scanner` для ввода данных пользователем.

##### Шаги алгоритма:
1. **Приветствие и инструкция:**
   - Выводится сообщение о начале работы калькулятора.
   - Указывается формат ввода: сначала дробь, затем операция.

2. **Создание начальной дроби:**
   - Вызывается метод `createFraction(scanner)`, который:
     - Запрашивает у пользователя числитель и знаменатель.
     - Обрабатывает ошибки ввода (не целое число, деление на ноль).
     - Возвращает корректную, сокращённую дробь типа `Fraction`.

3. **Цикл ввода операций:**
   - Пока пользователь не введёт `=`, программа продолжает запрашивать:
     - **Знак операции**: `+`, `-`, `*`, `/`, или `=`.
     - Если знак неверный — выводится ошибка, ввод повторяется.
   - Если введено `=` — выводится результат и программа завершается.

4. **Ввод следующей дроби:**
   - После выбора операции запрашивается вторая дробь (аналогично первой).

5. **Выполнение операции:**
   - В зависимости от знака, вызывается соответствующий метод класса `Fraction`.
   - Результат операции выводится в формате:  
     `"a/b + c/d = e/f"`
   - Результат становится новым текущим значением (`current`), чтобы можно было продолжить вычисления.

6. **Обработка ошибок:**
   - Все исключения (например, некорректный ввод, деление на ноль) перехватываются.
   - Сообщение об ошибке выводится в `System.err`, программа не падает.

7. **Завершение:**
   - При вводе `=` выводится финальный результат.
   - Цикл завершается, программа возвращается из метода `run`.


---

#### **Задача 10**
**Текст задачи**
Дороги. 
Измените сущности из задачи 1.3.3. Гарантируйте, что между двумя городами может быть только 
одна прямая дорога (другой путь может быть проложен только транзитом через другие города). 
Города можно создавать с указанием заранее заданных путей, в любой момент времени можно 
добавить новую дорогу в любой город и удалить имеющуюся дорогу.

**Алгоритм решения**  


---

### **Задание 2**
#### **Задача 5**
**Текст задачи**  
Маршрут.
Данная задача предполагает разработку новой сущности на основе той, что была получена в 
задаче 1.4.8 (Город). Сущность Город может быть доработана по своему усмотрению для более 
удобного использования.
Основная идея задачи в разработке такой сущности, которая будет представлять собой маршрут 
между двумя городами. Данный маршрут в любой момент времени можно получить как массив 
для дальнейшего использования. Сущность Маршрут имеет следующие характеристики:
• Имеет Город начала и Город конца пути. 
• Инициализация Маршрута может быть выполнена только если указана точка начала и 
конца пути. Если указано nullзначение - то ошибка.
• Точку начала и конца можно изменить в любой момент времени, но они всегда должны 
существовать.
• Может вернуть массив Городов, представляющий собой маршрут из начала в конец. 
Массив содержит все Города (в порядке очереди) через которые надо пройти что бы 
попасть из Города начала в Город конца, причем и начало и конец также содержатся в 
этом массиве. Алгоритм формирования пути в данном случае не существенен, можно 
выбрать вариант со случайным путем, путем проходящим через наименьшее число 
городов, или самым дешевым путем. Если путь найти невозможно – возвращается пустой 
массив. 
• Маршрут может быть приведен к строке, которая будет возвращать название всех 
городов маршрута в порядке очередности.
• Создание объекта и изменение точек начала и конца выполняется за константное время 
O(1).
Воспользуйтесь картой городов из задачи 1.3.3 и выведите маршрут из Города F в Город D

**Алгоритм решения**  


---

### **Задание 3**
#### **Задача 1**
**Текст задачи**  
Запретная Дробь. 
Измените сущность Дробь, полученную в задаче 2.1.4. Гарантируйте, что невозможно создать 
такой подвид дроби, который позволял бы создавать Дроби с изменяемым состоянием.

**Алгоритм решения**  


---

### **Задание 4**
#### **Задача 2**
**Текст задачи**
Дробь это число. 
Измените сущность Дробь, полученную в задаче 2.3.1. Дробь должна быть подтипом класса 
Number. Данный класс входит в стандартную редакцию языка Java.

**Алгоритм решения**  


---

### **Задание 5**
#### **Задача 1**
**Текст задачи**  
Сложение. 
Разработайте метод, который принимает набор числовых значенийи возвращает их сумму в 
вещественной форме. 

**Алгоритм решения**  

---

### **Задание 6**
#### **Задача 5**
**Текст задачи**  
Сравнение городов.
Измените сущность Город, полученную в задаче 2.1.10. Переопределите метод сравнения 
объектов по состоянию таким образом, чтобы два Города считались одинаковыми тогда, когда у 
них одинаковый набор путей в другие города. 

**Алгоритм решения**  

---

### **Задание 7**
#### **Задачи 1, 2, 3**
**Текст задач**  
1. Навести порядок. 
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее 
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались 
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму, 
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type
подставить название логического блока. Например, классы описывающие точку, линию, ломаную 
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете 
ru.surname.geometry

2. Главный метод.
Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную 
фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void
main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа 
в исполнение программы.

3. Возведение в степень. 
Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает 
метод результат возведения X в степень Y. Для преобразования строки в число следует 
использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите 
разработанный метод передав туда параметры командной строки полученные точкой входа в 
программу. Реализуйте метод так, что бы для возведения в степень и преобразования строки 
использовались короткие имена статических методов.

**Алгоритм решения**  

---

### **Задание 8**
#### **Задача 4**
**Текст задачи**  
Клонирование точки.
Измените сущность Точка из 2.6.2. Переопределите метод клонирования, унаследованный от 
класса Object, таким образом, чтобы при его вызове возвращался новый объект Точки, значения 
полей которого будут копиями оригинальной Точки.

**Алгоритм решения**  
